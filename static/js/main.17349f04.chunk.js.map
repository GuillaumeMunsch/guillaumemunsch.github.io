{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["App","props","updateWindowDimensions","setState","width","window","innerWidth","height","innerHeight","drawGrid","onCanvasPress","e","x","Math","floor","pageX","state","squareSize","y","pageY","headerHeight","map","row","canvasContext","fillRect","clearRect","canvas","refs","addEventListener","getContext","i","moveTo","lineTo","length","stroke","updateCell","neighbourCount","startAndStopGame","running","setTimeout","newMap","roundTime","Array","ceil","_","elem","this","removeEventListener","className","style","backgroundColor","onClick","disabled","type","value","onChange","parseInt","target","isNaN","ref","PureComponent","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.17349f04.chunk.js","sourcesContent":["import React, { PureComponent } from 'react';\nimport './App.css';\n\nconst DEFAULT_ROUND_TIME_VALUE = 200; // ms\n\ninterface State {\n    headerHeight: number;\n    width: number;\n    height: number;\n    squareSize: number;\n    map: boolean[][];\n    canvasContext?: any;\n    running: boolean;\n    roundTime: number;\n}\n\nclass App extends PureComponent<{}, State> {\n    constructor(props: {}) {\n        super(props);\n        const { innerWidth: width, innerHeight: height } = window;\n        const squareSize = 15;\n        this.state = {\n            width,\n            height,\n            headerHeight: 60,\n            squareSize,\n            map: [...Array(Math.ceil(width / squareSize))].map((_, x) =>\n                [...Array(Math.ceil(height / squareSize))].map((elem, y) => false),\n            ),\n            running: false,\n            roundTime: DEFAULT_ROUND_TIME_VALUE,\n        };\n    }\n    componentDidMount(): void {\n        window.addEventListener('resize', this.updateWindowDimensions);\n        this.drawGrid();\n    }\n\n    componentWillUnmount(): void {\n        window.removeEventListener('resize', this.updateWindowDimensions);\n    }\n\n    updateWindowDimensions = (): void => {\n        this.setState({ width: window.innerWidth, height: window.innerHeight }, this.drawGrid);\n    };\n\n    onCanvasPress = (e: any): void => {\n        const x = Math.floor(e.pageX / this.state.squareSize);\n        const y = Math.floor((e.pageY - this.state.headerHeight) / this.state.squareSize);\n        const map = [...this.state.map.map(row => [...row])];\n        map[x][y] = !map[x][y];\n        if (map[x][y])\n            this.state.canvasContext.fillRect(\n                x * this.state.squareSize,\n                y * this.state.squareSize,\n                this.state.squareSize,\n                this.state.squareSize,\n            );\n        else\n            this.state.canvasContext.clearRect(\n                x * this.state.squareSize + 1,\n                y * this.state.squareSize + 1,\n                this.state.squareSize - 1,\n                this.state.squareSize - 1,\n            );\n        this.setState({ map });\n    };\n\n    drawGrid = (): void => {\n        const canvas: any = this.refs.canvas;\n        canvas.addEventListener('mousedown', this.onCanvasPress, false);\n        const canvasContext = canvas.getContext('2d');\n        for (let i = 0; i < this.state.width; i += this.state.squareSize) {\n            // Drawing grid\n            canvasContext.moveTo(i, 0);\n            canvasContext.lineTo(i, this.state.height);\n            canvasContext.moveTo(0, i);\n            canvasContext.lineTo(this.state.width, i);\n        }\n        for (let x = 0; x < this.state.map.length; x++) {\n            for (let y = 0; y < this.state.map[x].length; y++) {\n                const elem = this.state.map[x][y];\n                if (elem) {\n                    canvasContext.fillRect(\n                        x * this.state.squareSize,\n                        y * this.state.squareSize,\n                        this.state.squareSize,\n                        this.state.squareSize,\n                    );\n                } else {\n                    canvasContext.clearRect(\n                        x * this.state.squareSize + 1,\n                        y * this.state.squareSize + 1,\n                        this.state.squareSize - 1,\n                        this.state.squareSize - 1,\n                    );\n                }\n            }\n        }\n        canvasContext.stroke();\n        this.setState({ canvasContext });\n    };\n\n    updateCell = (x: number, y: number, map: boolean[][]): boolean => {\n        let neighbourCount = 0;\n        if (x - 1 >= 0 && y - 1 >= 0 && map[x - 1][y - 1]) neighbourCount++; // Top left\n        if (y - 1 >= 0 && map[x][y - 1]) neighbourCount++; // Top\n        if (x + 1 < map.length && y - 1 >= 0 && map[x + 1][y - 1]) neighbourCount++; // Top right\n        if (x - 1 >= 0 && map[x - 1][y]) neighbourCount++; // Left\n        if (x + 1 < map.length && map[x + 1][y]) neighbourCount++; // Right\n        if (x - 1 >= 0 && y + 1 <= map[x].length && map[x - 1][y + 1]) neighbourCount++; // Bottom left\n        if (y + 1 <= map[x].length && map[x][y + 1]) neighbourCount++; // Bottom\n        if (x + 1 < map.length && y + 1 <= map[x].length && map[x + 1][y + 1]) neighbourCount++; // Bottom right\n        if (map[x][y]) {\n            // Cell alive for now\n            return neighbourCount === 2 || neighbourCount === 3;\n        }\n        // No cell for now\n        return neighbourCount === 3;\n    };\n\n    startAndStopGame = (): void => {\n        if (this.state.running) {\n            setTimeout(() => {\n                const newMap = [...this.state.map.map(row => [...row])];\n                for (let x = 0; x < newMap.length; x++)\n                    for (let y = 0; y < newMap[x].length; y++)\n                        newMap[x][y] = this.updateCell(x, y, this.state.map);\n                this.setState({ map: newMap }, () => {\n                    this.drawGrid();\n                    this.startAndStopGame();\n                });\n            }, this.state.roundTime);\n        }\n    };\n\n    render() {\n        return (\n            <div className=\"App\">\n                <div\n                    style={{\n                        height: this.state.headerHeight,\n                        backgroundColor: '#585858',\n                    }}\n                >\n                    <button\n                        onClick={(): void =>\n                            this.setState({ running: !this.state.running }, () =>\n                                this.startAndStopGame(),\n                            )\n                        }\n                    >\n                        {this.state.running ? 'Stop' : 'Start'}\n                    </button>\n                    <input\n                        disabled={this.state.running}\n                        type=\"text\"\n                        value={this.state.roundTime}\n                        onChange={(e: React.ChangeEvent<HTMLInputElement>): void => {\n                            let roundTime = parseInt(e.target.value);\n                            if (isNaN(roundTime)) roundTime = DEFAULT_ROUND_TIME_VALUE;\n                            this.setState({ roundTime });\n                        }}\n                    />\n                </div>\n                <canvas\n                    ref=\"canvas\"\n                    width={this.state.width}\n                    height={this.state.height - this.state.headerHeight}\n                />\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}